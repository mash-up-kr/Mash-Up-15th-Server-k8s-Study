대부분의 애플리케이션은 여러 개의 구성 요소로 나뉘며, k8s에서는 이 구성 요소를 각각 **파드 형태로 모델링**한다.

예) 웹 사이트는 웹 사이트 파드와 API 파드 2개로 구성이 되거나 MSA 구조를 채택해 파드 수십 개로 나뉘어 구성될 수 있다.

**모든 파드는 서로 통신할 수 있어야 한다**
- k8s는 파드의 통신을 위해 TCP와 UDP를 지원
- 두 프로토콜은 모두 IP 주소로 트래픽을 제어하는데, 파드를 대체할 때 IP 주소가 변경된다는 문제점이 발생
- k8s는 서비스에 어드레스 디스커버리 기능을 제공하여 이 문제를 해결함

**서비스란?**  
- 파드에서 들고나는 통신 트래픽의 라우팅을 맡는 리소스
- 통신 트래픽은 클러스터 외부에서 파드로 전달되는 것과 파드에서 클러스터 외부로 전달되는 것을 모두 포함

## 쿠버네티스 내부의 네트워크 트래픽 라우팅

파드가 통신하는데는 **IP 주소**가 필요하다.  
-> 파드가 새로운 파드로 교체될 때 IP 주소가 바뀌거나 교체된 파드의 새로운 IP 주소가 찾기 어려운 문제가 발생 

새로운 IP 주소는 **k8s API**를 통해서만 파악할 수 있다.

<실습1>  
파드를 2개 생성해 ping을 보내보기

→ `kubectl get pod -l app=sleep-2 --output jsonpath='.items[0].status.podIP}'` 와 같이 IP 주소를 찾아서 통신을 보내야 한다는 것을 알 수 있다. 

쿠버네티스가 만든 가상 네트워크는 클러스터 전체를 커버한다.  
따라서, **IP 주소만 있으면 다른 노드에서 실행중인 파드끼리도 통신이 가능하다.**

IP 주소는 파드가 대체될 때마다 바뀌기 때문에 이 방법은 일방적으로 사용하지 않는다.

<실습2>  
대체된 파드의 IP 주소를 확인해보기 -> IP 주소가 변경된다.


IP 주소 변경 문제는 어떻게 해결할 수 있을까?  
- 인터넷은 IP 주소에 기억하기 쉬운 이름을 붙이는 **도메인 네임**을 도입해 해결
- 쿠버네티스도 같은 해결책을 도입

쿠버네티스 클러스터에는 전용 DNS 서버가 있다.  
-> 이 서버가 서비스 이름과 IP 주소를 대응시켜준다.

파드는 도메인 네임을 통해 통신한다  
예시) 파드 → DNS 서버 → IP 주소 반환

**서비스의 특징**  
- 복수의 파드가 공유할 수 있는 가상 주소
- 서비스가 없으면 도메인 네임으로 접근 불가
- 파드와 파드가 가진 네트워크 주소를 추상화한 것(디플로이먼트가 파드와 파드가 포함하는 컨테이너를 추상화 한 것과 같음)
- 서비스 생성시 IP 주소가 클러스터 내 DNS 서버에 등록
- 레이블 셀렉터를 이용해 파드와 느슨한 연결을 가짐
- 자신만의 IP 주소를 가지며, 서비스가 삭제될 때까지 바뀌지 않는다.
    - 컨슈머 컴포넌트가 이 주소로 요청을 보내면 k8s가 서비스와 연결된 파드의 실제 IP 주소로 요청을 연결 


서비스 정의의 예

```jsx
apiVersion: v1
kind: Service

metadata:
	name: sleep-2 # 서비스 이름이 도메인 네임으로 사용
	
spec:
	selector:
		app: sleep-2 # app 레이블의 값이 sleep-2인 파드 대상
	ports:
		- port: 80
```

ping 명령은 ICMP 프로토콜을 사용하는데 서비스 리소스는 TCP/UDP 프로토콜을 지원하여 통신이 잘 되지 않는다.

## 파드와 파드 간 통신

**클러스터 IP**
- 서비스 유형 중 가장 기본
- 클러스터 전체에서 통용되는 IP 주소 생성
  - 파드가 어느 노드에 있더라도 접근은 가능하나, 클러스터 내에서만 유효한 주소
- 파드와 파드 간 통신에 사용
- 내부 접근은 허용하고, 외부 접근은 차단해야 하는 분산 시스템의 컴포넌트에 적합

YAML 스크립트를 작성할 때는 애플리케이션의 모든 컴포넌트와 통신 같이 세세한 부분까지 정의해줘야 한다.

## 외부 트래픽을 파드로 전달하기

클러스터 외부에서 들어오는 트래픽을 파드에 전달하는 방법  : 로드밸런서 서비스  
로드밸런서 유형의 서비스를 사용하면 트래픽을 받은 노드가 아닌 노드에서 실행되는 파드에도 트래픽을 전달할 수 있다.

흐름도  
외부 로드밸런서 → 로드밸런서 서비스 → 파드

**로드밸런서 서비스의 특징**
- 클러스터로 트래픽을 전달해주는 외부 로드밸런서와 함께 동작
- 레이블 셀렉터와 일치하는 파드로 트래픽 전달
- 클러스터 전체를 커버 가능
  - 어느 노드에 있는 파드라도 트래픽을 전달 가능
  - 대상 파드가 요청받은 노드에 있지 않아도 k8s가 올바른 노드까지 트래픽 전달

서비스의 레이블 셀렉터와 일치하는 파드가 많으면 파드보다 먼저 노드를 선택해야 하니 까다로워 보이지만 k8s가 알아서 해준다.

로드밸런서 서비스 정의의 예  
```jsx
apiVersion: v1
kind: Service

metadata:
	name: numbers-web
	
spec:
	ports:
		- port: 8080
			targetPort: 80
	selector:
		app: numbers-web
	type: LoadBalancer
```

8080 포트를 주시하다가 해당 포트로 들어오는 트래픽을 웹 애플리케이션 파드의 80번 포트로 전달한다고 정의되어 있다.  
이 서비스가 클러스터에 배포되면 kubectl로 따로 포트포워딩을 설정하지 않아도 웹 애플리케이션에 접근할 수 있다.

로드밸런서 서비스도 분산 환경에 따라 구현 방식의 차이가 발생한다.

- 도커 데스크톱의 쿠버네티스는 로컬 개발 환경이며, 이 클러스터는 단일 컴퓨터에서 동작한다. 
  - 모든 로드밸런서 서비스가 로컬호스트로 외부에 공개되기 때문에 여러 개의 로드밸런서 서비스를 사용하려면 포트를 각각 다르게 설정해야 한다.
- k3s 환경에서는 별도의 라우팅 테이블을 설정하는 방식으로 구현
  - 각각 로드밸런서 서비스는 호스트 컴퓨터의 IP 주소로 외부에 공개되기 대문에 로컬호스트 또는 IP 주소로 로드밸런서 서비스에 접근할 수 있다.
- AKS나 EKS의 경우 고가용성을 확보한 다중 노드 클러스터다. 
  - 이 클러스터에 로드밸런서 서비스를 배포하면 클라우드에 실제 로드밸런서가 만들어져 외부에서 들어오는 트래픽을 노드로 전달하고, 쿠버네티스가 이를 파드로 전달한다. 따라서 로드밸런서 서비스의 IP 주소도 각기 다르다.

**노드포트**  
- 외부에서 클러스터로 들어오는 트래픽을 파드로 전달하는 서비스 리소스 중 하나
- 외부 로드밸런서가 필요 없음 -> 트래픽이 곧바로 클러스터 노드로 인입
- 클러스터를 구성하는 모든 노드가 이 서비스에 지정된 포트를 주시하며 들어온 트래픽을 대상 파드의 대상 포트로 전달한다.
- 설정된 포트가 모든 노드에서 개방되어 있어야 함
- 다중 노드 클러스터에서 로드 밸런싱 효과를 얻을 수 없음
- 로드밸런서 서비스와 지원하는 분산 수준에 차이가 존재

통신 흐름  
노드→ 노드포트 서비스 → 파드

노드포트 서비스의 정의 예
```jsx
apiVersion: v1
kind: Service

metadata:
	name: numbers-web-node
	
spec:
	ports:
		- port: 8080 # 다른 파트가 서비스에 접근하기 위해 사용하는 포트
			targetPort: 80 # 대상 파드에 트래픽을 전달하는 포트
			nodePort: 30080 # 서비스가 외부에 공개되는 포트
	selector:
		app: numbers-node
	type: NodePort # 노드의 IP 주소를 통해 접근 가능한 서비스
```

## 쿠버네티스 클러스터 외부로 트래픽 전달하기

**익스터널네임 서비스**  
어떤 도메인 네임에 대한 별명  
익스터널네임 서비스가 도메인 네임의 별명을 만들고 파드가 그걸 사용하면, 쿠버네티스 DNS 서버에서 이 도메인 네임을 외부 도메인으로 해소한다.

애플리케이션 파드에서 로컬 네임을 생성하고, 쿠버네티스 DNS 서버에 이 로컬 네임을 조회하면 외부 도메인으로 해소해준다.

파드는 클러스터 외부의 컴포넌트와 통신하지만 파드에서 사용하는 도메인 네임이 로컬 도메인 네임이기에 이를 알지 못한다.

애플리케이션 설정에 포함하기 어려운 환경 간 차이를 반영할 때 유용하다.

캐노니컬 네임을 사용해 익스터널네임 서비스를 구현했다.

익스터널네임 서비스 정의의 예

```jsx
apiVersion: v1
kind: Service

metadata:
	name: numbers-api # 클러스터 안에서 쓰이는 로컬 도메인 네임
	spec:
		type: ExternalName
		externalName: raw.githubusercontent.com # 로컬 도메인 네임을 해소할 외부 도메인
```

익스터널네임 서비스는 애플리케이션이 사용하는 주소가 가리키는 대상을 치환해줄 뿐 요청 내용 자체를 바꿔주진 못한다.

TCP 프로토콜을 사용하면 문제없지만 HTTP 요청에는 헤더에 대상 호스트명이 들어가고, 호스트명이 익스터널네임 서비스의 응답과 다르다면 HTTP 요청이 실패하는 문제가 있다.

**헤드리스 서비스**  
익스터널네임 서비스와 비슷하게 도메인 네임 대신 IP  주소를 대체해주는 방법  
HTTP 헤더 문제를 해결하지는 못함

클러스터IP 형태로 정의되지만, 레이블 셀렉터가 없어 대상 파드가 없다. 대신 자신이 제공해야할 IP 주소의 목록이 담긴 엔드포인트 리소스와 함께 배포된다.

헤드리스 서비스 정의의 예

```jsx
apiVersion: v1
kind: Service
metadata:
	name: numbers-api
spec:
	type: ClusterIP
	ports:
		- port: 80
---
kind: Endpoints # 한 파일에 두 번째 리소스 정의
apiVersion: v1
metadata:
	name: numbers-api
subsets:
	- address:
		- ip: 192. 168. 123. 234
		ports:
			- ports: 80
```

## 쿠버네티스 서비스의 해소 과정

파드에서 동작하며 다른 파드와 통신하는 애플리케이션 컴포넌트도 표준 전송 프로토콜과 DNS 네임을 사용해 서로를 찾아낸다.

파드 → 쿠버네티스 DNS 서버   
파드 속 컨테이너가 요청한 도메인 네임 조회는 쿠버네티스 DNS 서버가 응답한다. 조회 대상이 서비스 리소스라면, DNS 서버는 클러스터 내 IP 주소 또는 외부 도메인 네임을 반환한다.

파드 → 쿠버네티스 네트워크 프록시  
**파드에서 나온 모든 통신은 네트워크 프록시가 라우팅**을 담당한다. 이 프록시는 각각의 노드에서 동작하며, 모든 서비스의 엔드포인트에 대한 최신 정보를 유지하고, 네트워크 패킷 필터를 통해 트래픽을 라우팅한다.  
파드는 각 노드마다 동작하는 네트워크 프록시를 경유하여 네트워크에 접근하고, 이 프록시는 패킷 필터링을 적용하여 가상 IP 주소를 실제 엔드포인트로 연결한다.


서비스에도 컨트롤러가 있어 파드가 변경될 때마다 엔드포인트의 목록을 최신으로 업데이트 한다. 따라서 클라이언트는 **가상 정적 IP와 네트워크 프록시**만 있으면 항상 최신 상태의 엔드포인트 목록을 적용받는다.

쿠버네티스 DNS 서버는 엔드포인트 IP 주소가 아닌 **클러스터의 IP 주소**를 반환한다. 엔드포인트가 가리키는 IP 주소는 계속 변화하기 때문이다.

정적 가상 IP 주소는 파드가 아무리 여러 번 교체되더라도 그대로 유지되기 때문에 클라이언트가 DNS 조회 결과를 영구적으로 캐시할 수 있다.

네임스페이스  
- 다른 리소스를 하나로 묶기 위한 리소스
- 모든 쿠버네티스 리소스는 네임 스페이스 안에 존재
- 쿠버네티스 클러스터를 논리적 파티션으로 나누는 역할
- 클러스터는 여러 개의 네임스페이스로 나뉠 수 있음
- 네임스페이스를 포함하는 완전한 도메인 네임으로도 서비스 접근 가능
- 네임스페이스 내부에서는 도메인 네임을 통해 서비스에 접근

→ 네임스페이스를 통해 보안을 해치지 않고도 클러스터 활용도를 높일 수 있다.

DNS 서버나 쿠버네티스 API 같은 쿠버네티스 내장 컴포넌트는 kube-system 네임스페이스에 속한 파드에서 동작한다.

서비스 이름은 로컬 도메인 네임으로 사용되는데, 이는 네임스페이스를 포함하는 완전한 도메인 네임의 별명이다.