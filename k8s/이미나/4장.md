# 컨피그맵과 비밀값으로 애플리케이션 설정하기

컨테이너에서 애플리케이션을 실행하면 다양한 환경 간 차이를 없앨 수 있다는 장점이 있다. 이를 위해 컨테이너에 환경별로 설정값을 주입해야 한다.

쿠버네티스에서는 **컨피그맵**과 **비밀값**을 통해서 컨테이너에 설정값을 주입할 수 있다.  

## 쿠버네티스에서 애플리케이션에 설정이 전달되는 과정

컨피그맵과 비밀값
- kubectl의 create 명령이나 YAML을 통해 생성 가능
- 다른 리소스와 달리 **스스로 어떤 기능을 하지 않음**
- 적은 양의 데이터를 저장하는 것이 목적
- 파드로 전달되어 컨테이너 환경의 일부가 되며, 컨테이너가 컨피그맵과 비밀값에 저장된 데이터를 읽을 수 있음

<실습 1>  
환경 변수 알아보기
`printevn`를 통해 환경 변수 조회

환경 변수는 파드의 생애 주기 내내 변하지 않는다  
-> 파드가 실행되는 중에는 환경 변수의 값을 수정할 수 없어 수정하고 싶다면 파드의 정의를 수정하고 파드를 수정된 버전으로 대체해야 한다.

이처럼 배치는 설정값을 바꾸거나 패치를 적용할 때도 필요하기 때문에, 애플리케이션은 잦은 파드 교체를 감안해 설계되어야 한다.

<실습 2>  
새로운 환경 변수가 추가된 파드 정의로 디플로이먼트 업데이트 해보기

실습 2를 살펴보면, 새로운 애플리케이션 역시 동일한 이미지를 사용하며, 바이너리 파일도 완전히 동일하다.  
간단한 설정이라면 파드 정의에 포함시켜도 괜찮지만, 복잡한 설정값의 경우 **컨피그맵**을 사용한다.

**컨피그맵이란?**  
파드에서 읽어 들이는 데이터를 저장하는 리소스  
한 개 이상의 키-값 쌍, 텍스트, 바이너리 파일 등 다양한 데이터 형태가 있다.  
특정 애플리케이션 전용으로 사용하거나, 여러 파드에서 공유하는 형태로도 사용할 수 있다.  
읽기 전용이며, 파드에서 내용을 수정할 수 없다.

예) 키-값 쌍을 저장했다면 파드에서 이를 환경 변수 형태로 주입할 수 있다.  
텍스트를 저장했다면 JSON, XML, YAML 등 설정 파일을 파드에 전달할 수 있다.

파드 하나에 여러 개의 컨피그맵을 전달할 수 있고, 하나의 컨피그맵을 여러 파드에 전달할 수도 있다.

정의에서 컨피그맵을 참조한 파드는 해당 컨피그맵이 있어야 클러스터에 배치할 수 있다.

## 컨피그맵에서 저장한 설정 파일 사용하기

환경 파일로 컨피그맵을 만들어 파드 속 컨테이너에 전달할 수 있다.  
예) .env 파일을 만들어 이 내용으로 컨피그맵을 설정

환경 변수 이름이 중복되는 경우 env 항목에서 정의된 값이 envFrom 항목에서 정의된 값에 우선한다. 
이런 우선순위는 컨테이너 이미지나 컨피그맵에서 정의된 환경 변수의 값을 파드 정의에서 수정할 수 있어 편리하다.

쿠버네티스는 스프링, Node.js, Go 등 애플리케이션 모두에 다음 설정 전략을 사용한다.
- 기본 설정값은 컨테이너 이미지에 포함시킨다.
- 각 환경의 실제 설정값은 컨피그맵에 담겨 컨테이너의 파일 시스템에 전달된다. 주로 설정 파일을 찾도록 지정한 경로에 설정 데이터를 파일 형태로 주입하거나 컨테이너 이미지에 담긴 파일을 덮어쓰는 형태
- 변경이 필요한 설정값은 디플로이먼트 내 파드 정의에서 환경 변수 형태로 적용한다.

설정을 컨피그맵으로 수정한 경우 다음 두 가지가 선행되어야 한다.
1. 컨피그맵이 주입한 데이터를 애플리케이션이 알아서 설정값에 병합해야 함
2. 파드 정의에서 컨피그맵을 참조하여 컨테이너 파일 시스템의 지정된 위치에 데이터를 들여 오도록 해야 함

## 4.3 컨피그맵에 담긴 설정값 데이터 주입하기

환경 변수 외에 컨테이너 파일 시스템 속 파일로 설정값을 주입할 수 있다.

컨테이너 파일 시스템은 컨테이너 이미지와 그 외 출처에서 온 파일로 구성되는 가상 구조다. 쿠버네티스는 이 파일 시스템 구성에 컨피그맵도 추가할 수 있다.  
컨피그맵은 디렉터리, 각 항목은 파일 형태로 컨테이너 파일 시스템에 추가된다.

이 과정에서는 파드 정의의 두 가지 항목과 관련된 기능이 관여한다.
- 볼륨
  - 컨피그맵에 담긴 데이터를 파드로 전달
- 볼륨 마운트
  - 컨피그맵을 읽어 들인 볼륨을 파드 컨테이너의 특정 경로에 위치시킴

컨피그맵을 볼륨 마운트 형태로 읽는 예
```yaml
spec:
  containers:
    - name: web
      image: kiamol/ch04-todo-list
      volumeMounts:                # 컨테이너에 볼륨을 마운트
        - name: config             # 마운트할 볼륨 이름
          mountPath: "/app/config"
          readOnly: true           
  volumes:                         # 볼륨은 파드 수준에서 정의
    - name: config                 # 이 이름이 볼륨 마운트의 이름과 일치해야 함
      configMap:                   # 볼륨의 원본은 컨피그맵
        name: todo-web-config-dev  # 내용을 읽어 올 컨피그맵 이름
```

컨피그맵은 디렉터리로 취급되며, 컨피그맵 속 각각의 항목이 컨테이너 파일 시스템 속 파일이 된다.  
-> 설정이 여러 파일에 나뉘어 있더라도 모든 설정을 하나의 컨피그맵으로 관리할 수 있다.

애플리케이션 관점에서는 컨테이너 파일 시스템이 하나의 스토리지로 보이나 실제로는 이미지와 컨피그맵을 합쳐 구성되었다.

파드가 동작 중인 상황에서 컨피그맵을 업데이트 하는 경우
- 쿠버네티스는 수정된 파일을 컨테이너에 전달
- 이후 과정은 애플리케이션 나름
  - 설정 파일 변경에 곧바로 반응하게 할 수 있음
  - 일부는 시작할 때 설정 파일을 읽은 다음 이후의 설정 디렉터리에서 일어나는 변화는 무시하는 경우도 있음
  - 이 경우 컨피그맵만 업데이트해서는 파드가 대체될 때 까지 아무것도 변하지 않음

주의 사항
- 볼륨 마운트가 의도한 대로 동작하지 않을 수 있다.
- 볼륨의 마운트 경로가 이미 컨테이너 이미지에 있는 경로라면, 컨피그맵 디렉터리가 원래 디렉터리를 덮어쓰고 디렉터리의 모든 내용이 교체된다.

컨피그맵 데이터를 컨테이너 파일 시스템에 전달하는 다른 방법  
컨피그맵의 모든 데이터 항목을 각각의 파일로 파일 시스템에 전달하는 대신, 필요한 항목을 골라 대상 디렉터리에 전달하는 방법도 있다.

컨피그맵은 텍스트파일을 잘 추상화한 객체일 뿐, 그 내용을 보호할 수 있는 보안적 수단이 없으므로 **민감한 데이터를 사용하지 말아야** 한다.

## 4.4 비밀값을 이용하여 민감한 정보가 담긴 설정값 다루기

비밀값은 컨피그맵과 사용 방법이 크게 다르지 않으나, 민감한 정보를 다루므로 클러스터 내부에서 별도로 관리된다.

해당 값을 사용해야 하는 노드에만 전달되며, 노드에서도 디스크에 저장하지 않고 메모리에만 담긴다. 또한, 전달 과정과 저장할 때 모두 암호화가 적용된다.

암호화는 항상 유지되는 것은 아니다.  
비밀값 객체에 접근할 권한이 있다면 비밀값의 평문을 읽을 수 있지만 난독화 계층이 하나 추가된다.(Base64 인코딩) 따라서, 완전한 평문을 보려면 Base64 디코더로 값을 파이핑 해야 한다.   
하지만 비밀값이 파드 컨테이너에 전달되고 나면 평문이 담긴 텍스트 파일이 된다.

환경 변수는 컨테이너에서 동작하는 모든 프로세스에서 접근이 가능하며, 애플리케이션 플랫폼 중에는 치명적 오류가 발생했을 때 모든 환경 변수를 로그로 남기는 경우도 있다.

따라서 비밀값의 데이터를 환경 변수로 들여올 때는 주의해야 하며, 대안은 비밀값을 파일 형태로 전달하는 방법이 있다. 이 경우, 애플리케이션이 설정 파일을 지원한다면 파일 권한 설정으로 민감한 정보를 지킬 수 있다.

## 4.5 쿠버네티스의 애플리케이션 설정 관리

설계 단계에서는 두 가지의 질문을 염두에 둬야 한다.
- 애플리케이션의 중단 없이 설정 변경에 대응이 필요한가?
- 민감 정보를 어떻게 관리할 것인가?

파드 교체조차 필요 없는 무중단 업데이트가 중요하다면
- 설정 업데이트에 파드 교체가 반드시 필요해지는 환경 변수는 활용할 수 없다.
- 볼륨 마운트를 이용해 설정 파일을 수정하여 기존 컨피그맵이나 비밀값을 업데이트 하는 방식이어야 한다.

컨피그맵이나 비밀값 등 설정 객체를 업데이트하지 않는 대안
- 설정 객체의 이름에 버전 명명법 도입
- 애플리케이션을 업데이트 할 때 새로운 설정 객체를 배치한 후 이 새로운 설정 객체를 가리키게 애플리케이션 정의를 수정
- 파드 교체 없는 업데이트는 포기해야 하지만 설정값 변경의 이력이 남아 롤백 가능

민감 정보 관리법
- 별도의 전담 팀을 통한 컨피그맵과 비밀값의 버전 관리 정책
- 형상 관리 도구에 저장된 YAML 템플릿 파일로 컨피그맵과 비밀값 정의 생성되는 완전 자동화된 배치
  - 파일엔 실제 민감 정보 대신 빈칸을 두고, 배치 절차 중에 이 빈칸을 안전한 곳에 보관되어 있던 실제 민감 정보로 채운다

환경에 무관하게 동일한 이미지를 사용하기 위해 애플리케이션 플랫폼을 통해 설정값이 주입되어야 한다는 점을 빼면 상황에 맞는 방식을 택하면 된다.


## 질문
예제 4-3 ~ 4-4 부분 실습 결과가 왜 이렇게 나오는걸까요?  
-> KIAMOL_SECTION의 결과가 다른 이유는?