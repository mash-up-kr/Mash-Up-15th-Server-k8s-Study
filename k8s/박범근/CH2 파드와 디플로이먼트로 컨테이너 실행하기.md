# CH2파드와 디플로이먼트로 컨테이너 실행하기

>> 쿠버네티스는 컨테이너로 어플리케이션을 실행하지만, 우리는 컨테이너를 직접 다루지 않는다. 모든 컨테이너는 파드에 속하는데, 파드란 쿠버네티스가 하나 또는 그 이상의 컨테이너를 관리하는 단위이다.
>> 쿠버네티스의 기본 단위이자 컨테이너를 실제 실행하는 역할을 담당하는 리소스인 파드와 파드의 관리를 담당하는 디플로이먼트(deployment)를 알아본다.

## 2.1 쿠버네티스는 어떻게 컨테이너를 실행하고 관리하는가
- 클러스터를 이루는 노드 > 파드 (컴퓨팅의 단위) > 컨테이너 (가상화된 환경)
- 파드는 쿠버네티스로 **관리되는 자신만의 가상 IP** 주소를 가지며 이 주소로 가상 네트워크에 접속한 다른 파드, 심지어 **다른 노드에서 실행되는 파드라도 통신**을 주고받을 수 있다.
- 파드 하나는 N개의 컨테이너를 포함할 수 있고 파드에 포함된 모든 컨테이너는 같은 가상 환경에 포함된다.
  - 따라서 네트워크를 공유하며 localhost로 통신이 가능하다.

```
파드 1 - IP : 10.1.0.12
파드 2 - IP : 10.1.0.36
각 파드에는 IP 주소가 부여되고 포함된 모든 컨테이너는 이 IP 주소를 공유한다.
파드끼리 쿠버네티스가 관리하는 가상 네트워크에 연결된다. IP 주소 기반 통신을 하며, 서로 다른 노드의 파드라도 통신이 가능하다.
```

<details>
<summary>노드와 파드</summary>

- 노드는 쿠버네티스에서 워커 머신
  - 물리 서버이거나 갓아 머신일 수도 있고, 각 노드는 kubelet (쿠버네티스 에이전트), 컨테이너 런타임 (docker 등), 네트워크 컴포넌트를 실행
- 파드는 쿠버네티스의 최소 실행 단위
  - 한 파드 안에 여러 컨테이너를 둘 수도, 하나를 둘 수도 있다.
  - 파드는 노드의 메모리와 CPU를 공유받아서 실행

</details>

<details>
<summary>Availability Zone 단위 노드 분산 + 글로벌 클러스터 구성</summary>

- AZ마다 노드 분산 배치 -> 고가용성을 위하 권장되는 전략
- 
|전략|설명|
|---|---|
| 멀티-AZ, 싱글 클러스터 | 보통 하나의 리전에 여러 AZ를 붙여 운영하는 방식. 네트워크 레이턴시 낮고 구성도 단순함.
|멀티-리전 클러스터 | 리전이 다른 인프라 (예: 서울 + 도쿄)에 노드를 두는 것. 네트워크가 WAN이라 레이턴시 높고 복잡.
|멀티 클러스터 구성 | 리전마다 별개의 클러스터를 두고, 이를 전역 서비스 혹은 GSLB 등으로 묶는 방식|

- 글로벌 로드밸런싱
  - DNS 기반 글로벌 라우팅
    - Geo DNS 등
  - 서비스 메시 (Istio, Linkerd + Multi-Cluster Gateway)
    - 하나의 서비스처럼 클러스터를 묶어서 트래픽 라우팅 가능

</details>

### 실습 #1
- 간단히 kubectl을 이용해서 파드를 띄워본다

```
# 컨테이너 이미지를 담은 파드를 실행
kubectl run hello-kiamol --image=kiamol/ch02-hello-kiamol

# 파드가 준비 상태가 될 때까지 기다린다
kubectl wait --for=condition=Ready pod hello-kiamol

# 클러스터 파드 목록을 출력한다
kubectl get pods

# 파드의 상세 정보를 확인
kubectl describe pod hello-kiamol
```

- 대부분의 파드는 하나의 컨테이너만을 실행 -> 쿠버네티스가 컨테이너를 실행하는 수단으로 생각해도 크게 틀리지 않다.
- **쿠버네티스가 직접 컨테이너를 실행하지는 않는다. 컨테이너 생성 책임은 해당 노드에 설치된 컨테이너 런타임에 맡기는 형태이다.**
  - 해당 런타임은 도커가 될 수도, 다른 특이한 것이 될 수 있다.

#### 기억해야 할 점
1. kubectl은 매우 강력한 도구
   1. 리소스 정보 중 내가 원하는 정보에 접근이 가능
   2. 자동화에 용이
2. 컨테이너를 실행시키는 건 쿠버네티스가 아니다.

- 또한 쿠버네티스는 컨테이너에 문제가 생기면, 새로운 컨테이너를 추가해서 파드 상태를 복원한다. 파드에 필요한 컨테이너 개수를 유지한다.

### 실습 #2
- 해당 파드에서 실행 중인 어플리케이션에 네트워크 트래픽을 연결해보자

```
# 로컬 컴퓨터의 8080번 포트를 주시하다가 이 파드로 들어오는 트래픽을 80으로 전달한다.
kubectl port-forward pod/hello-kiamo 8080:80

# 이후 http://localhost:8080에 접근한다.

```

## 2.2 컨트롤러 객체와 함께 파드 실행하기
- 파드만 사용하기엔 너무나 단순한 객체이다.
  - 어떤 노드가 고장을 일으키면 파드는 유실되며, 쿠버네티스는 유실된 파드를 새 파드로 대체하지 않는다.
  - 또한 모든 파드가 다른 노드에 흩어져서 실행된다는 보장이 없다.
- 억지로 컨트롤해야한다고 하면, 오케스트레이션 도구를 이용할 필요가 없다.


>> 컨트롤러 객체가 이 문제를 해결해준다. 컨트롤러 객체는 다른 리소스를 관리하는 쿠버네티스 리소스이다.

컨트롤러는 쿠버네티스 API와 연동하여 시스템의 현재 상황을 모니터링하다가 '바람직한 상태'와 차이가 생기면 필요에 따라 그 차이를 바로잡는다.
- 여러 가지 컨트롤러 객체가 존재하는데, 그 중 파드를 주로 관리하는 컨트롤러 객체는 디플로이먼트이다.

디플로이가 모든 문제를 해결해주는데
- 어떤 노드에 문제가 생겨서 파드가 유실되면, 디플로이먼트가 대체 파드를 다른 노드에 실행시킨다.
- 스케일링이 필요하면 필요한 파드 수를 지정한다. 그러면 디플로이먼트가 여러 노드에 걸쳐 필요한 파드 수만큼 파드를 실행한다.
- 디플로이먼트는 파드를 관리한다.

### 실습 #1
- 디플로이먼트를 통해 파드를 생성했고, 디플로이먼트가 필요한 파드의 정보를 알아내서 생성한다.
- 모든 쿠버네티스 리소스는 key-value로 값을 관리한다.
- 컨트롤러는 자신이 관리하는 리소스 목록을 직접 갖고 있지 않아도, 레이블을 이용해서 관리하는 리소스를 찾아볼 수 있다.
  - 디플로이먼트와 파드는 직접적인 관계를 갖지 않는다.
  - 디플로이먼트 입장에서는 레이블 셀렉터와 일치하는 파드가 있기만 하면 된다.
  - 따라서 파드의 인식할 수 있는 레이블을 수정하면 -> 디플로이먼트는 레이블 셀렉터와 일치하는 파드가 없어졌으므로 -> 개수를 유지하기 위해 새로운 파드를 띄운다.
    - 다시 레이블을 수정하면? -> 이 역시 개수를 맞추기 위해 하나의 파드를 제거한다.

### 실습 #2
- 네트워크 트래픽을 디플로이먼트로 포트포워딩하면, 디플로이먼트가 관리하는 파드 중 하나를 트래픽 전달 대상으로 삼는다.

## 2.3 어플리케이션 매니페스트에 배포 정의하기
- 쿠버네티스 정식 스크립트는 JSON이지만, 매니페스트 작성 시에 가독성이 더 뛰어나고 파일 하나에 더 많은 리소스를 정의할 수 있는 YAML을 많이 쓴다.
- kubectl 명령어보다 필요한 정보가 훨씬 많아졌지만
  - 어플리케이션 매니페스트의 장점은 선언적 스크립트라는 것이다.
    - kubectl의 경우 명령형이었고, 일일이 지시해야 한다.
    - 선언적 방식은 최종 결과를 알려주는 것이고, 과정은 따지지 않는다.
- 이제까지의 방식
  - 직접 팟을 생성
  - 디플로이먼트를 이용해 생성
  - 어플리케이션 매니페스트 파일을 이용해 생성
    - 정의 공유가 용이, 똑같은 배포를 반복할 수 있는 장점

## 2.4 파드에서 실행 중인 어플리케이션에 접근하기
- 파드와 디플로이먼트가 어플리케이션의 가용성을 확보하는 역할을 하더라도, 결국 실제 어플리케이션은 컨테이너 속에서 동작한다.

## 2.5 쿠버네티스의 리소스 관리 이해하기
- kubectl을 사용하면 쿠버네티스 리소스를 쉽게 삭제할 수 있지만 삭제한 리소스가 되살아나는 경우가 있다.
- 컨트롤러 객체가 만든 리소스의 삭제는 해당 컨트롤러 객체의 책임이다.

### 실습 #1
```
kubectl delete pods --all
```
로 모든 팟을 제거했지만
  - 디플로이먼트 객체가 관리하는 파드는 다시 생성됨
  - 컨트롤러 객체가 관리하는 리소스를 제거하기 위해선, 컨트롤러 객체 자체를 삭제해야 함 -> 자신이 관리하는 리소스를 말끔히 제거하고 삭제된다.

```
kubectl delete deploy --all

kubectl get pods 

kubectl get all
```

모두 삭제된 것을 확인할 수 있다.