# CH3 네트워크를 통해 서비스에 파드 연결하기

>> 파드는 쿠버네티스에서 어플리케이션을 구성하는 기본 요소이다. 모든 파드는 서로 통신할 수 있어야 한다. 파드끼리 통신을 위해 쿠버네티스는 표준 네트워크 프로토콜인 TCP와 UDP를 지원한다.
>> 이 두 프로토콜은 모두 IP 주소로 트래픽을 제어하는데, IP 주소는 파드를 대체할 때 주소가 변경된다는 문제가 있다. 쿠버네티스는 **서비스에 address discovery 기능을** 제공하여 이 문제를 해결했다.

- 서비스는 파드에서 들고나는 통신 트래픽의 라우팅을 맡는 유연한 리소스다. 이 트래픽은 클러스터 외부에서 파드로 전달되는 것과 파드에서 클러스터 외부로 전달되는 것 모두를 포함한다.

## 3.1 쿠버네티스 내부의 네트워크 트래픽 라우팅

- 이전 장에서 배운 점
  - 1. 파드는 쿠버네티스에서 부여한 IP 주소를 가진 가상 환경
  - 2. 파드가 다른 컨트롤러 객체 (Deployment)에 의해 생애 주기가 관장되는 '쓰고 버리는' 리소스라는 점

- 파드와 파드끼리 통신하기 위해선 IP 주소가 필요하다.
  - 이때 두 가지 문제점이 발생한다.
  - 1. 파드가 새로운 파드로 교체될 때 IP 주소가 변경되는 점
  - 2. 교체된 파드의 새로운 IP 주소를 찾기가 어렵다는 점

### 실습 #1
- 파드가 두 개 있으면 통신이 가능하다. 하지만 서로의 IP 주소를 알아야 한다.
- 쿠버네티스가 만든 가상 네트워크는 클러스터 전체를 커버한다.
  - 따라서 IP 주소만 있으면 서로 다른 노드에서 실행 중인 파드끼리도 통신이 가능하다.
- 하지만 IP 주소를 알아오는 방식의 통신은 일반적으로 사용하지 않는다.
  - 파드가 대체될 때마다 주소가 변경되기 때문이다.

### 실습 #2 
- 파드는 컨트롤러 객체인 디플로이먼트로 관리된다.
- 수동 삭제 시 디플로이먼트가 다른 IP 주소를 가진 새로운 파드를 생성한다.
- 이 문제는, 인터넷에서는 IP 주소에 기억하기 쉬운 이름을 붙이는 도메인 네임을 도입하여 해결했다.
- 쿠버네티스 역시, 동일한 해결책을 사용했는데 클러스터에는 전용 DNS 서버가 있다.
  - 이 서버가 서비스 이름과 IP 주소를 대응시켜 준다.
- 서비스 역시 레이블 셀렉터를 이용하여 파드와 느슨한 연결을 갖는다.
  - 서비스를 갖지 않은 파드는 도메인 네임으로 접근할 수 없다.

## 3.2 파드와 파드 간 통신
- 서비스의 유형 중 가장 기본이 되는 것을 클러스터 IP라고 한다.
  - 클러스터 전체에서 통용되는 IP, 클러스터 내에서만 유효

### 실습 #1
- 서비스를 생성하지 않은 어플리케이션이라, 파드 간 통신이 불가하다.
- 해당 어플리케이션에 대한 서비스를 추가한다.

### 실습 #2
- 서비스의 클러스터 IP가 해당 파드의 대문 역할을 한다.
- selector 이름에 일치하는 디플로이먼트에 포함된 파드로 트래픽을 연결해준다.

```
apiVersion: v1
kind: Service
metadata:
  name: web-service # 이름으로 DNS 쿼리 요청
spec:
  selector:
    app: web        # 라벨을 기반으로 백엔드 파드 찾기
  ports:
    - port: 80
      targetPort: 80


1. 클라이언트가 web-service 이름으로 DNS 쿼리 요청
- DNS는 web-service.default.svc.cluster.local → ClusterIP 반환

2. 클러스터 내부에서 ClusterIP로 요청이 들어옴

3. kube-proxy는 web-service의 selector (app=web)를 기준으로 파드를 찾아
- label app=web 을 가진 Pod 리스트를 Endpoints로 관리

4. 그 중 하나의 파드 IP로 트래픽을 포워딩
```
- 서비스 IP는 고정, 서비스 selector.app에 들어가는 동일한 하위 팟으로 트래픽이 전달, 신규 팟도 레이블이 일치하므로 서비스 하위에서 관리된다.
  - 이렇게 서비스 추상화를 통해서, 실제 파드의 이름 혹은 IP를 바라보는 것이 아니라 레이블 기반으로 동작하여 지속적인 파드 교체에도 서로 통신이 가능해진다.

## 3.3 외부 트래픽을 파드로 전달하기
- 클러스터 외부에서 들어오는 트래픽을 파드에 전달하는 여러 가지 방법이 있다.
- 가장 간단한 방법으로 **로드밸런서라는 유형의 서비스**를 사용한다.
  - 트래픽을 받은 노드가 아닌 노드에서 실행되는 파드에도 트래픽을 전달할 수 있다.
  - 로드밸런서 서비스의 커버 범위는 클러스터 전체이다.

### 실습 #1
- 로드밸런서를 클러스터에 배포 시 특정 포트를 리스닝하다 포워딩을 진행해준다.
- 로드 밸런서 서비스에는 클러스터 IP가 부여되고, 클러스터 내부 다른 파드는 서비스 이름으로 접근한다.
  - 외부 IP 주소를 주시하다가 해당 주소로 돌아오는 트래픽을 클러스터로 전달한다.

+ 노드 포트

## 3.4 쿠버네티스 클러스터 외부로 트래픽 전달하기
- 데이터베이스와 같은 스토리지 컴포넌트 등은 쿠버네티스 외부에서 동작하는 소프트웨어이다.
- 아키텍처와 무관하게 클러스터 외부를 가리키는 도메인 네임 해소에도 쿠버네티스 서비스 리소스를 활용할 수 있다.

1. 익스터널 네임 (ExternalName) 서비스 사용
- 어떤 도메인 네임에 대한 별명이라고 생각하면 쉽다.
- 쿠버네티스 DNS 서버에 로컬 네임을 조회하면 외부 도메인으로 해소해 주는 방식이다.
  - 내부에서 로컬 도메인 네임 (metadata.name) <-> 외부 도메인(externalName)과 매핑
  - db-service serviceName <-> app.database.io
=> DNS 표준 기능인 캐노니컬 네임 (Canonical Name, CNAME)을 사용하여 익스터널네임 서비스를 구현했다.

### 실습 #1
- 익스터널 네임의 증요한 특징
  - 클러스터 내 대상 이름을 치환해줄 뿐, 요청 자체의 내용을 바꾸지는 못한다.
  - HTTP 서비스의 경우 요청 헤더에 대상 호스트명이 들어가는데, 변경되지 않으므로 익스터널 네임 응답과 다를 경우 요청이 실패한다.
- 헤드리스 서비스 (headless Service)
  - 문제를 해결하기 위해 도메인 네임 대신 IP 주소를 대체해주는 방법이 있다.
  - 해당 서비스는 레이블 셀렉터가 없기에 대상 파드가 없지만, 자신이 제공해야 할 IP 주소의 목록이 담긴 엔드포인트 리소스와 함께 배포된다.
  - 존재하지 않는 주소로 배포되어도, 쿠버네티스에서는 검증을 하지 않는다.
  
  ## 3.5 쿠버네티스 서비스의 해소 과정
  - 쿠버네티스는 대부분의 네트워크 설정을 제공하는데, 안정적인 네트워크 기술에 기반을 둔 것이다.
    - 파드 속 컨테이너가 요청한 도메인 네임 조회는 DNS 서버가 응답한다. 조회 대상이 서비스 리소스라면, DNS 서버는 클러스터 내 IP 주소 혹은 외부 도메인 네임을 반환한다.
    - 파드에서 나온 모든 통신은 쿠버네티스의 또 다른 구성 요소인 네트워크 프록시가 라우팅을 담당한다.
      - 각각의 노드에서 프록시가 동작하며 모든 서비스의 엔드포인트에 대한 최신 정보를 유지한다.
  - 파드는 각 노드마다 동작하는 네트워크 프록시를 경유하여 네트워크에 접근한다.
    - 서비스 리소스는 삭제될 때까지 IP 주소가 바뀌지 않고 오래 지속된다.
    - 서비스에도 컨트롤러가 있어 파드가 변경될 때마다 엔드포인트의 목록을 최신으로 업데이트한다.
  - 따라서 클라이언트는 가상 정적 IP와 네트워크 프록시만 있으면 항상 최신 상태로 엔드포인트 목록을 유지할 수 있다.

### 네임 스페이스
- 모든 쿠버네티스 리소스는 네임스페이스 안에 존재한다.
- 쉽게 말해 다른 리소스를 하나로 묶기 위한 리소스다.
  - 클러스터를 논리적 파티션으로 나누는 역할을 하고, 팀별 혹은 제품별로 네임스페이스를 관리할 수 있다.
- 네임스페이스를 포함하는 완전한 도메인 네임으로도 서비스에 접근이 가능하다.