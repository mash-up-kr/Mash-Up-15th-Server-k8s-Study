# CH4 컨피그맵과 비밀값으로 어플리케이션 설정하기

>> 쿠버네티스에서 컨테이너에 설정값을 주입하는 데 쓰는 리소스는 컨피그맵과 비밀값 두 가지이다. 이 데이터는 클러스터 속에서 다른 리소스와 독립적인 장소에 보관된다.

## 4.1 쿠버네티스에서 어플리케이션에 설정이 전달되는 과정
- 컨피그맵과 비밀값 역시 다른 쿠버네티스 리소스와 마찬가지로 kubectl의 create 명령을 사용하거나 YAML 포맷으로 기재된 정의를 읽어 들여 생성할 수 있다.
- 다른 리소스와 달리 컨피그맵과 비밀값은 스스로 어떤 기능을 하지는 않는다. 단지 적은 양의 데이터를 저장하는 것이 목적이다.
  - 이들 리소스는 파드로 전달되어 컨테이너 환경의 일부가 되는데, 이 상태에서 컨테이너가 컨피그맵이나 비밀값에 저장된 데이터를 읽을 수 있다.
- 환경 변수는 파드의 생명 주기 내내 변하지 않는다.
  - 파드 실행 중에 환경 변수의 값을 수정할 수 없다.
  - 설정값을 바꾸거나 패치를 적용할 때도 배치가 필요하다. 꼭 새로운 기능이 추가될 때만 하는 것이 아니다.
  - 스프링 어플리케이션이 yml 설정 값을 읽어서 띄우는 것과 동일한 것으로 이해.

### 실습 #1
- 환경 변수를 추가하여 파드 정의를 변경함으로써 기존 파드가 새로운 파드로 교체된다.
  - 환경 변수는 리눅스와 윈도우 등 운영체제가 제공하는 핵심 기능이다.
- 간단한 설정이라면 이렇게 파드 정의에 포함시켜도 나쁘지 않다.
  - **그러나 실제 어플리케이션의 설정 값은 훨씬 복잡하기에, 이런 경우 컨피그 맵을 사용한다.**

- 컨피그맵은 파드에서 읽어 들이는 데이터를 저장하는 리소스이다.
- 컨피그맵에는 다양한 데이터의 형태로 저장되어 있고, 키-값쌍이나 텍스트를 통해 파드에 전달할 수 있다.
- 파드 하나에 여러 개의 컨피그 맵도 가능하고, 하나의 컨피그 맵을 여러 개의 파드에 전달할 수 있다.

### 실습 #2
- 정의에서 컨피그맵을 참조한 파드는 해당 컨피그맵이 있어야 클러스터에 배치할 수 있다.
- 여기에선 키-값 쌍을 데이터로 가진 sleep-config-literal이라는 이름의 컨피그맵이 필요하다.

```
- name: KIAMOL_SECTION
    valueFrom:
        configMapKeyRef:
            name: sleep-config-literal
            key: kiamol.section
```

## 4.2 컨피그맵에 저장한 설정 파일 사용하기
- 대부분의 어플리케이션 플랫폼에서는 더 다양한 우선순위를 가진 설정값이 필요하다.
  - 기본 설정값은 컨테이너 이미지에 포함시킨다.
  - 각 환경의 실제 설정값은 컨피그맵에 담겨 컨테이너의 파일 시스템에 전달된다. 컨테이너 이미지에 담긴 내용을 덮어 쓸 수 있다.
  - 변경이 필요한 설정값은 디플로이먼트 내 파드 정의에서 환경 변수 형태로 적용한다.

### 실습 1
- 수정된 파드의 정의를 컨피그맵을 참조하도록 변경
- 선행 조건은
  - 컨피그맵이 주입한 데이터를 어플리케이션이 알아서 설정값에 병합해야 함
  - 파드 정의에서 컨피그맵을 참조하여 컨테이너 파일 시스템의 지정된 위치에 데이터를 들여 오도록 해야 함

## 4.3 컨피그맵에 담긴 설정값 데이터 주입하기
- 환경 변수 외에 설정값을 전달하는 방법은 컨테이너 파일 시스템 속 파일로 설정값을 주입하는 것이다.
- 컨테이너 파일 시스템은 컨테이너 이미지와 그 외 출처에서 온 파일로 구성되는 가상 구조이다.
  - 쿠버네티스는 컨테이너 파일 시스템 구성에 컨피그맵도 추가할 수 있다.
- 컨피그맵에 담긴 데이터를 파드로 전달하는 **볼륨**과
- 컨피그맵을 읽어 들인 볼륨을 파드 컨테이너의 특정 경로에 위치시키는 **볼륨 마운트** 기능이 관여한다.

컨피그맵은 디렉터리로 취급되고, 컨피그맵 속 각각 항목은 컨테이너 파일 시스템 속 파일이 된다.

- 파드가 동작 중인 상황에서 컨피그맵을 업데이트하면 어떻게 될까?
  - 이 경우 쿠버네티스가 수정된 파일을 컨테이너에 전달한다. 하지만 그 이후의 과정은 어플리케이션 나름이다.
    - 일부는 어플리케이션 시작 시 설정 파일을 메모리로 읽어 들인 다음 이후의 설정 디렉토리에서 일어나는 변화는 무시한다.
    - 따라서 컨피그맵만 업데이트해서는 파드가 대체되기 전까지 아무것도 변하지 않는다.

Q. 볼륨 마운트 경로가 이미 컨테이너 이미지에 있는 경로라면
- 컨피그맵 디렉토리가 기존 디렉토리를 덮어쓰고 모든 내용이 교체되버린다. -> 문제가 발생한다.
- 새로운 파드가 정상적으로 시작되지 않으면, 기존 파드는 제거되지 않는다.

컨피그맵을 응용하면 다양한 설정 시스템에 대응할 수 있다. 설정값을 컨피그맵에 저장해 두고 환경 변수부터 볼륨 마운트까지 어플리케이션 요구에 맞추면 된다.
또한, 설정값과 어플리케이션 정의를 분리하면 각 팀이 각자의 담당 부분을 따로 처리할 수 있어 유연성이 생긴다.
**하지만 컨피그맵은 텍스트 파일을 잘 추상화한 객체일 뿐, 그 내용을 보호할 수 있는 보안적 수단은 전혀 없다.**

## 4.4 비밀값을 이용하여 민감한 정보가 담긴 설정값 다루기
- 비밀값은 컨피그맵과 비슷한 API를 가진 별개의 리소스다.
- 컨피그맵과 다른 점은, 민감한 정보를 다루므로 클러스터 내부에서 별도로 관리가 된다. 노출이 최소화된다.
  - 해당 값을 사용해야 하는 노드에만 전달되며, 노드에서도 디스크에 저장하지 않고 메모리에만 담긴다.
  - 암호화까진 아니고 Base64로 인코딩된 값이 출력된다.
    - 파드에 전달된 이후엔 평문이다.

비밀값의 데이터를 환경 변수로 들여오는 것은 주의해야 한다. 환경 변수는 컨테이너 동작 시 모든 프로세스에서 접근이 가능하다.
- 비밀값을 파일 형태로 전달하면, 파일 권한 설정으로 민감한 정보를 지킬 수 있다.

## 4.5 쿠버네티스의 어플리케이션 설정 관리
- 외부 환경에서 설정 값을 주입받아야 한다.
- 염두해야 할 질문
  1. 어플리케이션의 중단 없이 설정 변경에 대응이 필요한가?
  2. 민감 정보를 어떻게 관리할 것인가?

파드 교체조차 필요 없는 무중단 업데이트가 중요하다면 선택 범위는 제한적이다.
- 파드 교체가 반드시 필요한 환경 변수는 사용 불가능
- 볼륨 마운트를 이용하여 설정 파일을 수정하는 방식을 이용
  - 기존 컨피그맵이나 비밀값을 업데이트하는 방식이 필요
- 컨피그맵이나 비밀값 등 설정 객체를 업데이트하지 않는 대안은
  - 설정 객체의 버저닝을 통해서 v1, v2를 만들고 어플리케이션 정의에서 새로운 객체 정의를 바라보게끔 수정한다.
  - 파드 교체 없는 업데이트는 불가능하지만 설정값 변경의 이력이 남고 이전 버전으로의 롤백 대안이 될 수 있다.

민감 정보를 어떻게 관리할 것인지에 대해서
- 설정 파일 배포 관리 팀이 있다면, 컨피그맵과 비밀값의 버전 관리 정책이 정합.
- YAML 파일로 관리한다면, 정보가 채워질 공간을 만들어두고 vault와 같은 키 매니징 시스템에서 실제로 채워서 완성하는 방식이다.



------
- 컨피그맵은 파드에서 읽어 들이는 데이터를 저장하는 리소스이다.
  - 컨피그맵에는 다양한 데이터의 형태로 저장되어 있고, 키-값쌍이나 텍스트를 통해 파드에 전달할 수 있다.
- 비밀값은 컨피그맵과 비슷한 API를 가진 별개의 리소스다.
  - 컨피그맵과 다른 점은, 민감한 정보를 다루므로 클러스터 내부에서 별도로 관리가 된다. 노출이 최소화된다.