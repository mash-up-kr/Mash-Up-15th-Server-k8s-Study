# 2. 파드와 디플로이먼트로 컨테이너 실행하기
파드 : 쿠버네티스가 하나 또는 그 이상의 컨테이너를 관리하는 데 사용하는 단위

## 2.1. 쿠버네티스는 어떻게 컨테이너를 실행하고 관리하는가
### 2.1.1. 파드
컨테이너 : 애플리케이션 구성 요소 하나를 실행하는 가상화된 환경
쿠버네티스는 이 컨테이너를 파드로 감싼다.
  - 이때 파드는 자신만의 가상 IP 주소를 가진다.
  - 이 주소로 가상 네트워크에 접속된 다른 파드, 다른 노드에서 실행되는 파드라도 통신을 주고 받을 수 있다.

<img width="334" alt="Image" src="https://github.com/user-attachments/assets/270371a1-51d8-4f4c-9bd6-911c40e49175" />

즉, 파드 = 쿠버네티스가 컨테이너를 실행하는 수단

### 2.1.2. 쿠버네티스가 컨테이너를 직접 실행하지 않는 이유

컨테이너를 생성할 책임 -> 컨테이너 런타임에 맡긴다.
  - 컨테이너 런타임으로 될 수 있는 것 : 도커, 그 외
파드 : 쿠버네티스가 관리하는 리소스
컨테이너 : 쿠버네티스 외부에서 관리

파드의 컨테이너 개수가 0이 되자마자 쿠버네티스는 즉각 컨테이너를 생성하여 파드를 복원한다. -> 이를 `자가수복성`이라고 한다.

<br>

## 2.2. 컨트롤러 객체와 함께 파드 실행하기

파드는 직접 사용하기에는 너무 단순한 객체이다.
쿠버네티스는 유실된 파드를 새 파드로 대체하지 않는다.
억지로 서로 다른 노드에 실행되도록 사람이 관리해야 한다면 오케스트레이션 도구를 사용하는 의미가 없다.

-> 위와 같은 불편함을 해결해주는 것 : `컨트롤러 객체`
-> 그 중에서도 파드를 주로 관리하는 객체는 `디플로이먼트`


### 2.2.1 디플로이먼트는 파드를, 파드는 컨테이너를 관리한다.

<img width="417" alt="Image" src="https://github.com/user-attachments/assets/cb5285e9-d825-4c1a-aa9a-6289c4ba76cb" />

<br>

## 2.3. 애플리케이션 매니페스트에 배포 정의하기

매니페스트를 통해 버전 관리 및 동일한 배포가 가능하다.
포맷은 `JSON` 또는 `YAML`으로 작성 가능하다.
정식 스크립트 포맷은 `JSON`이지만, 매니페스트를 작성할 때는 `YAML`을 많이 쓴다.

```yaml
# 쿠버네티스 API 버전과 정의하려는 리소스 유형을 밝히며 시작한다.
apiVersion: v1
kind: Pod

# 리소스의 메타데이터에는 이름(필수)과 레이블(비필수)이 있다.
metadata :
  name: hello-kiamol-3

# 스펙은 리소스의 실제 정의 내용이다.
# 파드의 경우 : 실행할 컨테이너를 정의해야 한다.
# 컨테이너의 경우 : 이름과 이미지로 정의된다.
spec:
  containers:
  - name: web
    image: kiamol/ch02-hello-kiamol
```

방식의 차이
- `kubectl` : 명령형 방식, 일일이 지시하는 방식
- `Manifest` : 선언형 방식, 최종 결과만 알려주고 과정은 안 따지는 방식
  - 주의 : Manifest를 작성해도, 배포하려면 `kubectl`을 사용해야 한다.

```yaml
apiVersion: apps/v1
kind: Deployment

metadata:
  name: hello-kiamol-4

# 디플로이먼트가 자신의 관리 대상을 결정하는 레이블 셀렉터가 정의된다.
# 여기서는 app 레이블을 사용하는데, 레이블은 임의의 키-값 쌍이다.
spec:
  selector:
    matchLabels:
      app: hello-kiamol-4

  # 이 템플릿은 디플로이먼트가 파드를 만들 때 쓰인다.
  template:
    # 디플로이먼트 정의 속 파드의 정의에는 이름이 없다.
    # 단, 레이블 셀렉터와 일치하는 레이블을 지정해야 한다.
    metadata:
      labels:
        app: hello-kiamol-4
    spec:
      # 컨테이너 이름과 이미지 이름을 지정한다.
      containers:
        - name: web
          image: kiamol/ch02-hello-kiamol
```

<br>

## 2.4. 파드에서 실행 중인 애플리케이션에 접근하기

- 파드 내에 접근하는 명령어 실행 시, 주의해야 할 점 : `kubectl` 문법 변경
`kubectl exec -it hello-kiamol sh` 대신 `kubectl exec -it hello-kiamol -- sh`로 사용해야 함


<br>

## 2.5. 쿠버네티스 리소스 관리 이해하기

kubectl을 사용하면 리소스를 쉽게 삭제할 수 있지만, 삭제한 리소스가 되살아나는 경우가 있다.
컨트롤러 객체가 만든 리소스의 삭제는 해당 **컨트롤러 객체의 책임**이다.
이 객체가 만든 리소스의 생애 주기는 외부 간섭을 용인하지 않는다.
따라서 이 리소스를 삭제하려면 컨트롤러 객체를 삭제해야 한다.

완전히 삭제하고 싶다면?
- `kubectl delete pods --all`
- `kubectl delete deploy --all`

---

### 궁금한 점
Q. 왜 파드는 다른 노드에서 흩어져서 실행되어야 하는가?
A. `안정성`, `효율성`, `확장성` 때문이다. 
  - 같은 서비스를 하는 파드가 하나의 노드에 몰려있는 상태에서, 그 노드가 죽으면 서비스 전체가 영향을 받는다.
  - 한 노드에 파드가 몰리면 병목이 발생할 수 있음
  - 수평 확장이 쉬워진다.


