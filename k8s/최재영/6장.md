# 6. 컨트롤러 리소스를 이용한 애플리케이션 스케일링

동일한 애플리케이션이 돌아가는 파드 = `replica`
-> 노드가 여러 개인 클러스터에서 레플리카는 여러 노드에 분산 배치된다.

<br>

## 6.1. 쿠버네티스는 어떻게 애플리케이션을 스케일링하는가

파드 = 쿠버네티스에서 컴퓨팅 단위
컨트롤러 = 파드를 관리하는 리소스, 디플로이먼트를 주로 사용한다.
레플리카셋 = 파드를 직접 관리하는 역할

<img width="381" alt="Image" src="https://github.com/user-attachments/assets/04330f40-bdf6-4522-8b4d-6b84c9d6767d" />

디플로이먼트 = 레플리카셋을 관리하는 컨트롤러 리소스
레플리카셋 = 파드를 관리하는 컨트롤러 리소스

애플리케이션에 스케일링이 어떻게 빨리 적용되는가?

- 노드에서 파드를 실행하려면 이미지를 먼저 내려받아야 한다.
- 따라서 스케일링이 적용되는 데 걸리는 시간은 노드에서 이미지를 내려받는 시간보다 빠를 수 없다.

똑같은 서비스 리소스를 향해 보낸 HTTP 요청이 서로 다른 파드에서 처리될 수 있는 이유

- 서비스와 파드는 "**느슨한 결합**"을 한다.
- 따라서 쿠버네티스는 이들 파드에 요청을 고르게 분배할 수 있다.

<br>

## 6.2. 디플로이먼트와 레플리카셋을 이용한 부하 스케일링

- 디플로이먼트는 여러 개의 레플리카셋을 관리할 수 있다.

<img width="323" alt="Image" src="https://github.com/user-attachments/assets/b36850b9-dcfa-4f66-8399-f3344ff97c29" />

<img width="472" alt="Image" src="https://github.com/user-attachments/assets/4211a57b-fa50-48c7-83e8-d9ab9ac597a5" />

nginx는 캐시 디렉터리를 다른 nginx 인스턴스와 공유하더라도 별다른 문제를 일으키지 않는다.

데몬셋과 스테이트풀셋 = 파드를 관리하는 컨트롤러

<br>

## 6.3. 데몬셋을 이용한 스케일링으로 고가용성 확보하기

데몬셋 = 클로스터 내 모든 노드(또는 셀렉터)와 일치하는 일부 노드에서 "**단일 레플리카(또는 파드)**"로 동작하는 리소스

레플리카를 관리하는 규칙 : 데몬셋과 디플로이먼트는 다르다.
하지만 데몬셋 역시 파드를 관리하는 "컨트롤러"이다.
-> 따라서 파드가 유실되면 대체 파드를 생성한다.

<br>

## 6.4. 쿠버네티스의 객체 간 오너십

쿠버네티스에는 관리 주체가 사라진 객체를 찾아 제거하는 가비지 컬렉터가 있다.
객체 간 이런 오너십은 일종의 위계를 형성한다.

파드 = 레플리카셋의 관리를 받음
레플리카셋 = 디플로이먼트의 관리를 받음
이러한 관계를 형성하는 수단은 오직 `레이블 셀렉터` 뿐이다.
따라서 레이블을 멋대로 수정하면 이런 의존 관계가 깨질 수 있다.

<img width="381" alt="Image" src="https://github.com/user-attachments/assets/b6f8b101-32f3-4acf-81a0-01f1e053b4d5" />
